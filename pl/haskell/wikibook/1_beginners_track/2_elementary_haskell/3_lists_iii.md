# Lists III

## Folds 

Όπως η ```map```, η ```fold``` είναι μια συνάρτηση υψηλότερης τάξης που δέχεται μια συνάρτηση και μια λίστα. Ωστόσο, αντί, όπως στην περίπτωση της ```map```, να εφαρμόζει τη συνάρτηση στοιχείο προς στοιχείο, η ```fold``` συνδυάζει τα στοιχεία της λίστας προκειμένου να προκύψει μια τιμή αποτελέσματος.

**Παράδειγμα sum**

```
sum :: [Integer] -> Integer
sum []     = 0
sum (x:xs) = x + sum xs
```

**Παράδειγμα product**

```
product :: [Integer] -> Integer
product []     = 1
product (x:xs) = x * product xs
```

**Παράδειγμα concat**

```
concat :: [[a]] -> [a]
concat []     = []
concat (x:xs) = x ++ concat xs
```

Οι παραπάνω συναρτήσεις αποτελούν πρότυπα αναδρομής γνωστά ως ```fold```.

Το Prelude ορίζει 4 ```fold``` συναρτήσεις: ```fold```: ```foldr```, ```foldl```, ```foldr1``` ```foldl1```.

**foldr**

Το δεξιά-προσεταιριστικό (right-associative) ```foldr``` διπλώνει μια λίστα από τα δεξιά προς τα αριστερά. Καθώς διανύει τη λίστα, το ```foldr``` χρησιμοποιεί τη συνάρτηση που δίνεται έτσι ώστε να συνδυάσει κάθε τιμή με την τρέχουσα τιμή του συσσωρευτή (accumulator). Όταν καλείται η ```foldr``, η αρχική τιμή του accumulator αποτελεί όρισμα.

```
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f acc []     = acc
foldr f acc (x:xs) = f x (foldr f acc xs)
```




