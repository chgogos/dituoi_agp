# Lists III

## Folds 

Όπως η ```map```, η ```fold``` είναι μια συνάρτηση υψηλότερης τάξης που δέχεται μια συνάρτηση και μια λίστα. Ωστόσο, αντί, όπως στην περίπτωση της ```map```, να εφαρμόζει τη συνάρτηση στοιχείο προς στοιχείο, η ```fold``` συνδυάζει τα στοιχεία της λίστας προκειμένου να προκύψει μια τιμή αποτελέσματος.

**Παράδειγμα sum**

```
sum :: [Integer] -> Integer
sum []     = 0
sum (x:xs) = x + sum xs
```

**Παράδειγμα product**

```
product :: [Integer] -> Integer
product []     = 1
product (x:xs) = x * product xs
```

**Παράδειγμα concat**

```
concat :: [[a]] -> [a]
concat []     = []
concat (x:xs) = x ++ concat xs
```

Οι παραπάνω συναρτήσεις αποτελούν πρότυπα αναδρομής γνωστά ως ```fold```.

Το Prelude ορίζει 4 ```fold``` συναρτήσεις: ```fold```: ```foldr```, ```foldl```, ```foldr1``` ```foldl1```.

**foldr - fold right to left**

Η δεξιά-προσεταιριστική (right-associative) ```foldr``` διπλώνει μια λίστα από τα δεξιά προς τα αριστερά. Καθώς διανύει τη λίστα, η ```foldr``` χρησιμοποιεί τη συνάρτηση που δίνεται έτσι ώστε να συνδυάσει κάθε τιμή με την τρέχουσα τιμή του συσσωρευτή (accumulator). Όταν καλείται η ```foldr```, η αρχική τιμή του accumulator περνά ως όρισμα.

```
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f acc []     = acc
foldr f acc (x:xs) = f x (foldr f acc xs)
```

Το πρώτο όρισμα της foldr είναι μια συνάρτηση με 2 ορίσματα. Το δεύτερο όρισμα είναι η τιμή του accumulator (συχνά έχει την τιμή 0). Το τρίτο όρισμα είναι η λίστα που θα διπλωθεί.

* Στη συνάρτηση sum, f είναι το (+) και το acc είναι 0.
* Στη συνάρτηση product, f είναι το (*) και το acc είναι 1.
* Στη συνάρτηση concat, f είναι το (++) και το acc είναι [].


Άθροισμα στοιχείων λίστας με την ```foldr```

```
Prelude> foldr (+) 0 [1,2,3,4]
10
```

Γινόμενο στοιχείων λίστας με την ```foldr```

```
Prelude> foldr (*) 1 [1,2,3,4]
24
```

Συνένωση λιστών με την ```foldr```

```
Prelude> foldr (++) "" ["Hello", " ", "World", "!!!"]
"Hello World!!!"
```

**Identity function**
Η εφαρμογή της ```foldr (:) []``` σε μια λίστα επιστρέφει τη λίστα χωρίς αλλαγές. Τέτοιες συναρτήσεις ονομάζονται ταυτότητες (identity functions).

```
Prelude> foldr (:) [] [1,2,3,4]
[1,2,3,4]
```

Παρατηρήστε ότι οι παρενθέσεις συσσωρεύονται στη δεξιά πλευρά.
```
foldr f acc (a:b:c:[]) = f a (f b (f c acc))
```


**foldl - fold left to right**

Η αριστερά-προσεταιριστική (left-associative) ```foldl``` επεξεργάζεται τα στοιχεία στην αντίθετη κατεύθυνση από την ```foldr```, ξεκινώντας από την αριστερή πλευρά με το πρώτο στοιχείο.

```
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f acc []     =  acc
foldl f acc (x:xs) =  foldl f (f acc x) xs
```

Παρατηρήστε ότι οι παρενθέσεις συσσωρεύονται στην αριστερή πλευρά.

```
foldl f acc (a:b:c:[]) = f (f (f acc a) b) c
```

**Είναι τα foldl και foldr αντίθετα;**

Γιατί;
```
Prelude> foldl (-) 6 [3, 2, 1]
0
Prelude> foldr (-) 6 [1, 2, 3]
-4
```

Η διαφορά foldr και foldl αφορά τον τρόπο με τον οποίο η τελική έκφραση προσαιτερίζεται, και όχι την αριστερά προς τα δεξιά σειρά που διανύονται τα στοιχεία  της λίστας. 

```
foldl (-) 6 [3, 2, 1] == ((6 - 3) - 2) - 1
foldr (-) 6 [1, 2, 3] == 1 - (2 - (3 - 6))
```

**foldr1 and foldl1**


**folds και laziness**

Έστω η συνάρτηση ```echoes``` η οποία δέχεται μια λίστα ακεραίων και παράγει μια λίστα όπου όταν συναντάται ο αριθμός ```n``` στη λίστα εισόδου, να αντιγράφεται τόσες φορές στη λίστα εξόδου. Θα χρησιμοποιήσουμε τη συνάρτηση του prelude ```replicate``` που εφόσον κληθεί ως ```replicate n x``` δημιουργεί μια λίστα με ```n``` φορές το στοιχείο ```x```.

Η συνάρτηση ```echoes``` μπορεί να γραφεί με την ```foldr```.

```
echoes :: [Int] -> [Int]
echoes = foldr (\ x xs -> (replicate x x) ++ xs) []
```
Παρατηρήστε τον ορισμό ```\ x xs -> (replicate x x)```. Το ```\``` μοιάζει κάπως με λάμδα και ξεκινά τον ορισμό μιας ανώνυμης συνάρτησης (μιας συνάρτησης που ορίζεται για να χρησιμοποιηθεί μόνο εκεί), τα ```x``` και ```xs``` είναι ορίσματα και ότι ακολουθεί μετά το ```->``` είναι το δεξί μέρος του ορισμού της συνάρτησης.

Δοκιμή της ```echoes``` που έχει οριστεί με την ```foldr```

```
Prelude> take 10 (echoes [1..])
[1,2,2,3,3,3,4,4,4,4]
```

Αν η συνάρτηση ```echoes``` είχε γραφεί με την ```foldl```.

```
echoes :: [Int] -> [Int]
echoes = foldl (\ xs x -> xs ++ (replicate x x)) []
```

Δοκιμή της ```echoes``` που έχει οριστεί με την ```foldl```

```
Prelude> take 10 (echoes [1..])

```

Η ```echoes``` που έχει οριστεί με την ```foldl``` δεν τερματίζει ποτέ!


Η συνάρτηση ```map``` μπορεί να υλοποιηθεί ως fold:

```
map :: (a -> b) -> [a] -> [b]
map f = foldr (\ x xs -> f x : xs) []
```

Τα folds αν και θέλουν χρόνο για τα συνηθίσει κανείς, αποτελούν θεμελιώδες pattern στο συναρτησιακό προγραμματισμό και τελικά η χρήση τους δεν ξαφνιάζει. Οποτεδήποτε θέλουμε να διασχίσουμε μια λίστα και να κατασκευάσουμε ένα αποτέλεσμα από τα στοιχεία της, είναι πολύ πιθανό να χρειαστούμε κάποιο fold. 


## Scans

Τα scans συμπεριφέρεται ως διασταύρωση ```map``` και fold.

Το prelude περιέχει 4 συναρτήσεις scan: ```scanl```, ```scanr```, ```scanl1```, ```scanr1```

```
scanl :: (a -> b -> a) -> a -> [b] -> [a]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
```

Παραδείγματα

```
Prelude> scanl (+) 0 [1,2,3]
[0,1,3,6]
Prelude> scanl1 (+) 0 [1,2,3]
[1,3,6]
Prelude> scanr (+) 0 [1,2,3]
[6,5,3,0]
Prelude> scanr1 (+) [1,2,3]
[6,5,3]
```

## filter

Μια συχνή λειτουργία που πραγματοποιείται σε λίστες είναι το φιλτράρισμα, δηλαδή η δημιουργία μιας νέας λίστας που αποτελείται μόνο από τα στοιχεία της λίστας που ικανοποιούν κάποια συγκεκριμένα κριτήρια.

Παράδειγμα: συνάρτηση retainEven που δημιουργεί μια λίστα μόνο με τους άρτιους αριθμούς από μια λίστα ακεραίων.

```
retainEven :: [Int] -> [Int]
retainEven [] = []
retainEven (n:ns) =
-- mod n 2 computes the remainder for the integer division of n by 2.
  if (mod n 2) == 0
    then n : (retainEven ns)
    else retainEven ns
```

Το παραπάνω μπορεί να γίνει κομψότερα με τη συνάρτηση ```filter``` από το prelude.

```
filter :: (a -> Bool) -> [a] -> [a]
```

Ο τύπος λέει ότι η filter δέχεται μια συνάρτηση ```(a -> Bool)``` και μια λίστα ```[a]``` και επιστρέφει μια λίστα ```[a]```. Η συνάρτηση ελέγχει τα στοιχεία για τον αν ικανοποιούν κάποια συνθήκη.

Για παράδειγμα η retainEven μπορεί να γραφεί χρησιμοποιώντας την ```filter```.

```
isEven :: Int -> Bool 
isEven n = (mod n 2) == 0
```

```
retainEven ns = filter isEven ns
```

το παραπάνω μπορεί να γραφεί ισοδύναμα και με τον ακόλουθο point-free ορισμό.

```
retainEven = filter isEven
```

## List comprehensions (περιφραστικές λίστες)

Τα list comprehensions είναι ένας απλούστερος τρόπος (syntactic sugar) για να περιγραφούν κάποιες κοινές λειτουργίες σε λίστες όπως το φιλτράρισμα. Για παράδειγμα αντί να χρησιμοποιηθεί η συνάρτηση filter του Prelude μπορεί να γραφεί η συνάρτηση retainEven ως εξής.

```
retainEven es = [n | n <- es, isEven n]
```

Τα list comprehensions μπορούν εύκολα να επεκταθούν. Μπορούν να χρησιμοποιούν πολλούς ελέγχους (ακόμα και κανένα) χωρίζοντάς τους μεταξύ τους με κόμματα. Για παράδειγμα η συνάρτηση retainLargeEvens τροποποιεί την ```retainEven``` έτσι ώστε να διατηρεί μόνο τους αριθμούς που είναι μεγαλύτεροι του 100.

```
retainLargeEvens :: [Int] -> [Int]
retainLargeEvens es = [n | n <- es, isEven n, n > 100]
```

H συνάρτηση ```evensMinusOne``` χρησιμοποιεί μια έκφραση για τον υπολογισμό των στοιχείων της νέας λίστας.

```
evensMinusOne es = [n - 1 | n <- es, isEven n]
```

Μαζί με τα list comprehensions μπορεί να χρησιμοποιηθεί και το pattern matching. Για παράδειγμα έστω ότι έχουμε μια λίστα με ζεύγη ```(Int, Int)``` και θέλουμε να κατασκευάσουμε μια λίστα με το πρώτο στοιχείο κάθε ζεύγους που το δεύτερο στοιχείο του είναι άρτιο.

Ένας τρόπος είναι να γραφεί το εξής:

```
firstForEvenSeconds :: [(Int, Int)] -> [Int]
firstForEvenSeconds ps = [fst p | p <- ps, isEven (snd p)]
```

Ένας καλύτερος τρόπος με pattern matching είναι:

```
firstForEvenSeconds ps = [x | (x, y) <- ps, isEven y]
```

Επίσης, ένα comprehension μπορεί να χρησιμοποιεί δύο ή περισσότερες λίστες. Στο ακόλουθο παράδειγμα χρησιμοποιούνται δύο λίστες και επιπλέον εφαρμόζεται και ένας έλεγχος.

```
Prelude> somePairs = [(x, y) | x <- [1..4], y <- [5..8], x + y > 8]
Prelude> somePairs
[(1,8),(2,7),(2,8),(3,6),(3,7),(3,8),(4,5),(4,6),(4,7),(4,8)]
```

