# 1. Εισαγωγή

* Γιατί δεν αρκεί η καλή γνώση 1-2 γλωσσών προγραμματισμού;
* Βασικές επιρροές στη σχεδίαση γλωσσών προγραμματισμού: αρχιτεκτονική Η/Υ + μεθοδολογίες σχεδίασης προγραμμάτων

## 1.1 Λόγοι μελέτης εννοιών γλωσσών προγραμματισμού

* Αυξημένη δυνατότητα έκφρασης ιδεών. Για παράδειγμα προγραμματιστής της C που γνωρίζει τη χρήση των πινάκων συσχέτισης στην Perl μπορεί να σχεδιάσει παρόμοιες δομές ή να αναζητήσει βιβλιοθήκες που υλοποιούν πίνακες σχεδίασης στη C όπως η [GLib - Hash Tables](https://developer.gnome.org/glib/stable/glib-Hash-Tables.html).
* Βελτιωμένο υπόβαθρο για την επιλογή κατάλληλων γλωσσών προγραμματισμού για νέα έργα. 
* Ευκολία εκμάθησης νέων γλωσσών προγραμματισμού. Για παράδειγμα η εκμάθηση της Ruby από προγραμματιστές που κατανοούν τις βασικές αρχές του αντικειμενοστραφούς προγραμματισμού καθίσταται ευκολότερη καθώς η Ruby είναι αντικειμενοστραφής.
  * Η δημοφιλία των γλωσσών προγραμματισμού παρουσιάζει σημαντικές διακυμάνσεις 
    * [TIOBE index](https://www.tiobe.com/tiobe-index/)
  * Γνώση λεξιλογίου που χρησιμοποιείται σε γλώσσες προγραμματισμού και μεταγλωττιστές (π.χ. δυναμική πρόσδεση)
* Καλύτερη κατανόηση της σημασίας υλοποίησης. Για παράδειγμα η γνώση του τρόπου με τον οποίο πραγματοποιείται η κλήση υποπρογραμμάτων μπορεί να εξηγήσει την ενδεχόμενη αργή εκτέλεση που δημιουργεί η κλήση ενός μικρού υποπρογράμματος πολλές φορές.
* Καλύτερη χρήση γλωσσών που είναι ήδη γνωστές.
* Αναβάθμιση γνώσεων πληροφορικής και ανάπτυξη ικανότητας επιχειρηματολογίας για λόγους επικράτησης συγκεκριμένων γλωσσών προγραμματισμού έναντι άλλων (π.χ. FORTRAN vs ALGOL).

## 1.2 Τομείς προγραμματισμού

Οι Η/Υ χρησιμοποιούνται σε πάρα πολλούς και διαφορετικούς μεταξύ τους κλάδους όπως οι επιστημονικές εφαρμογές, οι επιχειρηματικές εφαρμογές, οι εφαρμογές τεχνητής νοημοσύνης, οι εφαρμογές για τον παγκόσμιο ιστό, οι τηλεπικοινωνίες, τα βιντεοπαιχνίδια κ.α. Συνεπώς, η ανάπτυξη γλωσσών προγραμματισμού με διαφορετικούς στόχους σχεδίασης είναι μια πραγματικότητα.

* **Επιστημονικές εφαρμογές**. Η αρχική απαίτηση ήταν για πράξεις με δεκαδικούς αριθμούς κινητής υποδιαστολής και επεξεργασία δεδομένων σε διανύσματα και δισδιάστατους πίνακες. Στο παρελθόν κυρίαρχη γλώσσα για επιστημονικές εφαρμογές ήταν η FORTRAN η οποία έπρεπε να ανταγωνισθεί σε ταχύτητα την ASSEMBLY. Σήμερα χρησιμοποιούνται για επιστημονικές εφαρμογές πολλές γλώσσες προγραμματισμού με σημαντικότερες τις FORTRAN, C, C++, Python, R, Java, MATLAB, Julia κ.α.
* **Επιχειρηματικές εφαρμογές**. Καλύπτουν απαιτήσεις  παραγωγής αναφορών (reports), επεξεργασίας δεκαδικών αριθμών και αλφαριθμητικών.
  * COBOL (1960)
  * [COBOL Programmers are Back In Demand. Seriously.](https://cacm.acm.org/news/244370-cobol-programmers-are-back-in-demand-seriously/fulltext) 
* **Τεχνητή νοημοσύνη**. Δίνεται έμφαση σε συμβολικές και όχι σε αριθμητικές πράξεις, δηλαδή πράξεις πάνω σε σύμβολα που διατηρούνται σε συνδεδεμένες δομές δεδομένων.
  * Lisp (1959)
  * Prolog (1970)
  * Python, C, C++, Java κ.α.
* **Παγκόσμιος ιστός**.
  * HTML (markup language) + CSS
  * Ενσωμάτωση κώδικα (JavaScript, PHP) σε έγγραφα HTML

## 1.3 Κριτήρια αποτίμησης γλωσσών προγραμματισμού

### Κριτήρια: 

* Δυνατότητα ανάγνωσης (readability)
* Δυνατότητα γραφής 
* Αξιοπιστία
* Κόστος
  * Κόστος εκπαίδευσης στη γλώσσα προγραμματισμού.
  * Κόστος δημιουργίας προγραμμάτων. Οι αρχικές προσπάθειες κατασκευής γλωσσών προγραμματισμού βασίζονταν στην επιθυμία μείωσης του κόστους ανάπτυξης του λογισμικού.
  * Κόστος μεταγλώττισης.
  * Κόστος εκτέλεσης. Μολονότι στο παρελθόν η αποδοτικότητα της εκτέλεσης ήταν ο κύριος παράγοντας που λαμβάνονταν υπόψη κατά τη σχεδίαση των πρώτων γλωσσών προγραμματισμού, σήμερα δεν έχει μεγάλη σημασία στις περισσότερες περιπτώσεις.
    * Βελτιστοποίηση (διάρκεια μεταγλώττισης/ταχύτητα εκτέλεσης παραγόμενου κώδικα)
  * Κόστος συστήματος υλοποίησης της γλώσσας προγραμματισμού (π.χ. Java->δωρεάν, Ada->ακριβοί μεταγλωττιστές πρώτης γενιάς)
  * Κόστος αναξιοπιστίας (πιθανότητα αγωγών αποζημίωσης)
  * Κόστος συντήρησης προγραμμάτων. Εκτιμάται ότι το κόστος συντήρησης μπορεί να είναι διπλάσιο ή ακόμα και τετραπλάσιο από το κόστος ανάπτυξης του λογισμικού

### Χαρακτηριστικά 

#### Απλότητα

**Πολλαπλότητα χαρακτηριστικών (feature multiplicity)**: Οι πολλαπλοί τρόποι με τους οποίους μπορεί να επιτευχθεί ένα αποτέλεσμα επηρεάζουν την απλότητα. Για παράδειγμα στον ακόλουθο κώδικα σε Java η μοναδιαία αύξηση της μεταβλητής count επιτυγχάνεται με 4 διαφορετικούς τρόπους.

```java
count = count + 1;
count += 1;
++count;
count++;
```

**Υπερφόρτωση τελεστών**: Ερμηνεία ενός τελεστή με περισσότερους από έναν τρόπους. Για παράδειγμα η υπερφόρτωση του τελεστή + για διανύσματα μπορεί να υλοποιηθεί με διαφορετικούς και μη διαισθητικά ορθούς τρόπους.

Η υπερβολική απλότητα μιας γλώσσας μπορεί να υποβαθμίζει την αναγνωσιμότητα των προγραμμάτων που είναι γραμμένα σε αυτή (π.χ. Assembly).

#### Ορθογωνικότητα

Ορθογωνικότητα σημαίνει ότι λίγα μόνο πρωτογενή δομικά στοιχεία μπορούν να συνδυαστούν με σχετικά λίγους τρόπους έτσι ώστε να κατασκευαστούν οι δομές ελέγχου και δεδομένων της γλώσσας. Επιπλέον, κάθε πιθανός συνδυασμός των πρωτογενών δομικών στοιχείων είναι έγκυρος και έχει νόημα.  

Για παράδειγμα σε μια υποθετική γλώσσα με τύπους δεδομένων int, float, char και τους τελεστές τύπων διατάξεων και δεικτών, η έλλειψη ορθογωνικότητας θα σήμαινε ότι δεν θα μπορούσε να οριστεί κάποιος συνδυασμός τύπου δεδομένων και τελεστή τύπων όπως ο δείκτης σε διάταξη. 

Μεγαλύτερη ορθογωνικότητα συνεπάγεται λιγότερες εξαιρέσεις σε κανόνες της γλώσσας.

Οι συναρτησιακές γλώσσες (Lisp, Scheme, Haskell, ...) προσφέρουν μεγαλύτερη ορθογωνικότητα από προστακτικές γλώσσες (C, C++, Java, Python, ...), αλλά υστερούν σε ταχύτητα εκτέλεσης.

##### Παραδείγματα έλλειψης ορθογωνικότητας στη C

1. Μολονότι η C διαθέτει 2 είδη δομημένων τύπων δεδομένων, τις διατάξεις και τις εγγραφές (struct), οι εγγραφές μπορούν να επιστρέφονται από συναρτήσεις αλλά όχι οι διατάξεις. Ωστόσο, θα πρέπει να σημειωθεί ότι η C επιτρέπει την επιστροφή ενός δείκτη προς μια διάταξη.

* [orthogonality_violation1.c](./../../pl/c/orthogonality_violation1.c)

2. Ένα μέλος μιας δομής μπορεί να είναι οποιουδήποτε τύπου δεδομένων εκτός από void ή μια δομή του ίδιου τύπου. Ωστόσο ένα μέλος μιας δομής μπορεί να είναι δείκτης προς void ή δείκτης προς δομή του ίδιου τύπου.

* [orthogonality_violation2.c](./../../pl/c/orthogonality_violation2.c)

3. Ένα στοιχείο μιας διάταξης μπορεί να είναι οποιοδήποτε τύπος δεδομένων εκτός από void ή μια συνάρτηση. Ωστόσο, μπορεί να είναι δείκτης προς void ή δείκτης προς συνάρτηση.

* [orthogonality_violation3.c](./../../pl/c/orthogonality_violation3.c)

4. Οι παράμετροι συναρτήσεων περνούν με τιμή εκτός αν είναι διατάξεις οπότε περνούν με αναφορά (επειδή η εμφάνιση του ονόματος μιας διάταξης χωρίς δείκτη ερμηνεύεται ως η διεύθυνση του πρώτου στοιχείου της διάταξης)

* [orthogonality_violation4.c](./../../pl/c/orthogonality_violation4.c)

5. Εξάρτηση από τα συμφραζόμενα για τον τελεστή + στην έκφραση a + b. Αν το a είναι δείκτης προς μια τιμή float που καταλαμβάνει 4 bytes τότε η τιμή του b θα πολλαπλασιαστεί επί 4 πριν προστεθεί στο a.

* [orthogonality_violation5.c](./../../pl/c/orthogonality_violation5.c)

---

#### Τύποι δεδομένων

* Μια γλώσσα προγραμματισμού που περιέχει τύπο δεδομένων Boolean είναι περισσότερη εκφραστική έναντι κάποιας γλώσσας που δεν περιέχει τύπο δεδομένων Boolean και χρησιμοποιεί ειδικές τιμές για να υποδηλώσει το αληθές ή ψευδές.

  * [boolean1.c](./../../pl/c/boolean1.c) 
  * [boolean2.c](./../../pl/c/boolean2.c) 


#### Σχεδίαση συντακτικού

* H Ada χρησιμοποιεί το end if ώστε να τερματίσει μια δομή επιλογής και το end loop για να τερματίσει μια δομή επανάληψης. Αντίθετα η C χρησιμοποιεί την αγκύλη } για το τερματισμό όλων των μπλοκ εντολών. Ποιο είναι καλύτερο;
* Η Fortran 95 επιτρέπει τον ορισμό μεταβλητών με το ίδιο όνομα με λέξεις με ειδική σημασία στη γλώσσα όπως οι Do και End. Η C δεν επιτρέπει τη χρήση λέξεων όπως η for, if κλπ και τις θεωρεί δεσμευμένες. Ποιο είναι καλύτερο;

#### Εκφραστικότητα

* Η Ada διαθέτει τους λογικούς τελεστές **and then** και **οr else** που αποτελούν πρακτικούς τρόπους σύντομης αποτίμησης μιας boolean έκφρασης <https://en.wikibooks.org/wiki/Ada_Programming/Keywords/and>

#### Έλεγχος τύπων

* Ο έλεγχος τύπων κατά την εκτέλεση είναι ακριβός και προτιμάται ο έλεγχος τύπων κατά τη μεταγλώττιση.
* linters της C 
  * https://invisible-island.net/personal/lint-tools.html#tool_lint
  * http://cppcheck.sourceforge.net/

#### Χειρισμός εξαιρέσεων

Με τη χρήση εξαιρέσεων (exceptions) δίνεται η δυνατότητα του χειρισμού σφαλμάτων εκτέλεσης έτσι ώστε να πραγματοποιούνται διορθωτικές κινήσεις. Με τον τρόπο αυτό αυξάνεται η αξιοπιστία του προγράμματος.

* Οι C++, C#, Java, Python κ.α. έχουν δυνατότητες χειρισμού εξαιρέσεων.
* Η C δεν έχει μηχανισμό χειρισμό εξαιρέσεων.

#### Ψευδωνυμία

Η ψευδωνυμία αναφέρεται στη χρήση δύο ή περισσότερων ονομάτων για πρόσβαση δεδομένων που βρίσκονται στην ίδια θέση μνήμης.

* [alias.c](./../../pl/c/alias.c)
* [alias.cpp](./../../pl/cpp/sandbox/alias.cpp)

## 1.4 Επιρροές στη σχεδίαση γλωσσών προγραμματισμού

### 1.4.1 Αρχιτεκτονική υπολογιστών

### 1.4.2 Μεθοδολογίες σχεδίασης προγραμματισμού

## 1.5 Κατηγορίες γλωσσών προγραμματισμού

## 1.6 Συμβιβασμοί στη σχεδίαση γλωσσών προγραμματισμού

## 1.7 Μέθοδοι υλοποίησης

### 1.7.1 Μεταγλώττιση

### 1.7.2 Καθαρή διερμηνεία

### 1.7.3 Υβριδικά συστήματα υλοποίησης

### 1.7.4 Προεπεξεργαστές

## 1.8 Προγραμματιστικά περιβάλλοντα

