# 1. Εισαγωγή

* Γιατί δεν αρκεί η καλή γνώση 1-2 γλωσσών προγραμματισμού;
* Βασικές επιρροές στη σχεδίαση γλωσσών προγραμματισμού: αρχιτεκτονική Η/Υ + μεθοδολογίες σχεδίασης προγραμμάτων

## 1.1 Λόγοι μελέτης εννοιών γλωσσών προγραμματισμού

* Αυξημένη δυνατότητα έκφρασης ιδεών. Για παράδειγμα προγραμματιστής της C που γνωρίζει τη χρήση των πινάκων συσχέτισης στην Perl μπορεί να σχεδιάσει παρόμοιες δομές ή να αναζητήσει βιβλιοθήκες που υλοποιούν πίνακες σχεδίασης στη C όπως η [GLib - Hash Tables](https://developer.gnome.org/glib/stable/glib-Hash-Tables.html).
* Βελτιωμένο υπόβαθρο για την επιλογή κατάλληλων γλωσσών προγραμματισμού για νέα έργα. 
* Ευκολία εκμάθησης νέων γλωσσών προγραμματισμού. Για παράδειγμα η εκμάθηση της Ruby από προγραμματιστές που κατανοούν τις βασικές αρχές του αντικειμενοστραφούς προγραμματισμού καθίσταται ευκολότερη καθώς η Ruby είναι αντικειμενοστραφής.
  * Η δημοφιλία των γλωσσών προγραμματισμού παρουσιάζει σημαντικές διακυμάνσεις 
    * [TIOBE index](https://www.tiobe.com/tiobe-index/)
  * Γνώση λεξιλογίου που χρησιμοποιείται σε γλώσσες προγραμματισμού και μεταγλωττιστές (π.χ. δυναμική πρόσδεση)
* Καλύτερη κατανόηση της σημασίας υλοποίησης. Για παράδειγμα η γνώση του τρόπου με τον οποίο πραγματοποιείται η κλήση υποπρογραμμάτων μπορεί να εξηγήσει την ενδεχόμενη αργή εκτέλεση που δημιουργεί η κλήση ενός μικρού υποπρογράμματος πολλές φορές.
* Καλύτερη χρήση γλωσσών που είναι ήδη γνωστές.
* Αναβάθμιση γνώσεων πληροφορικής και ανάπτυξη ικανότητας επιχειρηματολογίας για λόγους επικράτησης συγκεκριμένων γλωσσών προγραμματισμού έναντι άλλων (π.χ. FORTRAN vs ALGOL).

## 1.2 Τομείς προγραμματισμού

Οι Η/Υ χρησιμοποιούνται σε πάρα πολλούς και διαφορετικούς μεταξύ τους κλάδους όπως οι επιστημονικές εφαρμογές, οι επιχειρηματικές εφαρμογές, οι εφαρμογές τεχνητής νοημοσύνης, οι εφαρμογές για τον παγκόσμιο ιστό, οι τηλεπικοινωνίες, τα βιντεοπαιχνίδια κ.α. Συνεπώς, η ανάπτυξη γλωσσών προγραμματισμού με διαφορετικούς στόχους σχεδίασης είναι μια πραγματικότητα.

* **Επιστημονικές εφαρμογές**. Η αρχική απαίτηση ήταν για πράξεις με δεκαδικούς αριθμούς κινητής υποδιαστολής και επεξεργασία δεδομένων σε διανύσματα και δισδιάστατους πίνακες. Στο παρελθόν κυρίαρχη γλώσσα για επιστημονικές εφαρμογές ήταν η FORTRAN η οποία έπρεπε να ανταγωνισθεί σε ταχύτητα την ASSEMBLY. Σήμερα χρησιμοποιούνται για επιστημονικές εφαρμογές πολλές γλώσσες προγραμματισμού με σημαντικότερες τις FORTRAN, C, C++, Python, R, Java, MATLAB, Julia κ.α.
* **Επιχειρηματικές εφαρμογές**. Καλύπτουν απαιτήσεις  παραγωγής αναφορών (reports), επεξεργασίας δεκαδικών αριθμών και αλφαριθμητικών.
  * COBOL (1960)
  * [COBOL Programmers are Back In Demand. Seriously.](https://cacm.acm.org/news/244370-cobol-programmers-are-back-in-demand-seriously/fulltext) 
* **Τεχνητή νοημοσύνη**. Δίνεται έμφαση σε συμβολικές και όχι σε αριθμητικές πράξεις, δηλαδή πράξεις πάνω σε σύμβολα που διατηρούνται σε συνδεδεμένες δομές δεδομένων.
  * Lisp (1959)
  * Prolog (1970)
  * Python, C, C++, Java κ.α.
* **Παγκόσμιος ιστός**.
  * HTML (markup language) + CSS
  * Ενσωμάτωση κώδικα (JavaScript, PHP) σε έγγραφα HTML

## 1.3 Κριτήρια αποτίμησης γλωσσών προγραμματισμού

### Κριτήρια: 

* Δυνατότητα ανάγνωσης (readability)
* Δυνατότητα γραφής 
* Αξιοπιστία
* Κόστος

### Χαρακτηριστικά 

#### Απλότητα

**Πολλαπλότητα χαρακτηριστικών (feature multiplicity)**: Οι πολλαπλοί τρόποι με τους οποίους μπορεί να επιτευχθεί ένα αποτέλεσμα επηρεάζουν την απλότητα. Για παράδειγμα στον ακόλουθο κώδικα σε Java η μοναδιαία αύξηση της μεταβλητής count επιτυγχάνεται με 4 διαφορετικούς τρόπους.

    ```java
    count = count + 1;
    count += 1;
    ++count;
    count++;
    ```

**Υπερφόρτωση τελεστών**: Ερμηνεία ενός τελεστή με περισσότερους από έναν τρόπους. Για παράδειγμα η υπερφόρτωση του τελεστή + για διανύσματα μπορεί να υλοποιηθεί με διαφορετικούς και μη διαισθητικά ορθούς τρόπους.

Η υπερβολική απλότητα μιας γλώσσας μπορεί να υποβαθμίζει την αναγνωσιμότητα των προγραμμάτων που είναι γραμμένα σε αυτή (π.χ. Assembly).

#### Ορθογωνικότητα

Ορθογωνικότητα σημαίνει ότι λίγα μόνο πρωτογενή δομικά στοιχεία μπορούν να συνδυαστούν με σχετικά λίγους τρόπους έτσι ώστε να κατασκευαστούν οι δομές ελέγχου και δεδομένων της γλώσσας. Επιπλέον, κάθε πιθανός συνδυασμός των πρωτογενών δομικών στοιχείων είναι έγκυρος και έχει νόημα.  

Για παράδειγμα σε μια υποθετική γλώσσα με τύπους δεδομένων int, float, char και τους τελεστές τύπων διατάξεων και δεικτών, η έλλειψη ορθογωνικότητας θα σήμαινε ότι δεν θα μπορούσε να οριστεί κάποιος συνδυασμός τύπου δεδομένων και τελεστή τύπων όπως ο δείκτης σε διάταξη. 

Μεγαλύτερη ορθογωνικότητα συνεπάγεται λιγότερες εξαιρέσεις σε κανόνες της γλώσσας.

Οι συναρτησιακές γλώσσες (Lisp, Scheme, Haskell, ...) προσφέρουν μεγαλύτερη ορθογωνικότητα από προστακτικές γλώσσες (C, C++, Java, Python, ...), αλλά υστερούν σε ταχύτητα εκτέλεσης.

##### Παραδείγματα έλλειψης ορθογωνικότητας στη C

1. Μολονότι η C διαθέτει 2 είδη δομημένων τύπων δεδομένων, τις διατάξεις και τις εγγραφές (struct), οι εγγραφές μπορούν να επιστρέφονται από συναρτήσεις αλλά όχι οι διατάξεις. Ωστόσο, θα πρέπει να σημειωθεί ότι η C επιτρέπει την επιστροφή ενός δείκτη προς μια διάταξη.

* [orthogonality_violation1.c](./../../pl/c/orthogonality_violation1.c)

2. Ένα μέλος μιας δομής μπορεί να είναι οποιουδήποτε τύπου δεδομένων εκτός από void ή μια δομή του ίδιου τύπου. Ωστόσο ένα μέλος μιας δομής μπορεί να είναι δείκτης προς void ή δείκτης προς δομή του ίδιου τύπου.

* [orthogonality_violation2.c](./../../pl/c/orthogonality_violation2.c)

3. Ένα στοιχείο μιας διάταξης μπορεί να είναι οποιοδήποτε τύπος δεδομένων εκτός από void ή μια συνάρτηση. Ωστόσο, μπορεί να είναι δείκτης προς void ή δείκτης προς συνάρτηση.

* [orthogonality_violation3.c](./../../pl/c/orthogonality_violation3.c)

4. Οι παράμετροι συναρτήσεων περνούν με τιμή εκτός αν είναι διατάξεις οπότε περνούν με αναφορά (επειδή η εμφάνιση του ονόματος μιας διάταξης χωρίς δείκτη ερμηνεύεται ως η διεύθυνση του πρώτου στοιχείου της διάταξης)

* [orthogonality_violation4.c](./../../pl/c/orthogonality_violation4.c)

5. Εξάρτηση από τα συμφραζόμενα για τον τελεστή + στην έκφραση a + b. Αν το a είναι δείκτης προς μια τιμή float που καταλαμβάνει 4 bytes τότε η τιμή του b θα πολλαπλασιαστεί επί 4 πριν προστεθεί στο a.

* [orthogonality_violation5.c](./../../pl/c/orthogonality_violation5.c)
